<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Riffle - Music Quiz</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
    body { font-family: 'Montserrat', sans-serif; }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .pulse-animation {
      animation: pulse 2s infinite;
    }
    
    .progress-bar {
      transition: width 0.1s linear;
    }
    
    .answer-btn:hover:not(.selected) {
      transform: translateY(-2px);
    }
    
    /* Duration bar styling */
    #music-duration-bar {
      background: rgba(0, 0, 0, 0.5);
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
    }
    
    #music-progress {
      transition: width 0.1s linear;
    }
    
    .answer-btn.selected {
      transform: translateY(1px);
    }
    
    .answer-btn.correct {
      background: rgba(16, 185, 129, 0.9) !important;
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.7);
    }
    
    .answer-btn.wrong {
      background: rgba(239, 68, 68, 0.9) !important;
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.7);
    }
    
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: #f00;
      border-radius: 0;
    }
    
    @keyframes fadeAndMove {
      0% { transform: translateY(0) rotate(0); opacity: 1; }
      100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
    }
    
    /* Music playback animations */
    @keyframes musicBarAnimation {
      0% { height: 5px; opacity: 0.7; }
      50% { height: 20px; opacity: 1; }
      100% { height: 5px; opacity: 0.7; }
    }
    
    @keyframes audioBarAnimation {
      0% { height: 5px; }
      50% { height: 15px; }
      100% { height: 5px; }
    }
    
    .audio-bars-container {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }
    
    .audio-bar {
      width: 3px;
      height: 5px;
      background: linear-gradient(to top, #9333ea, #6366f1);
      border-radius: 1px;
      transition: height 0.1s ease;
    }
    
    .audio-bar.active {
      animation: audioBarAnimation 0.5s ease-in-out infinite;
      box-shadow: 0 0 5px rgba(139, 92, 246, 0.7);
    }
    
    /* Audio visualizer styles */
    .visualizer-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 40px;
      width: 100%;
      margin-top: 10px;
    }
    
    .visualizer-bar {
      width: 4px;
      height: 20px;
      margin: 0 2px;
      background: linear-gradient(to top, #6366f1, #a855f7);
      border-radius: 2px;
      transition: height 0.2s ease;
    }
    
    /* Music playback indicator */
    #music-playing-indicator {
      margin-top: 12px;
      padding: 8px 12px;
      border-radius: 20px;
      background-color: rgba(0, 0, 0, 0.3);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      backdrop-filter: blur(5px);
    }
  </style>
</head>
<body class="bg-gradient-to-br from-gray-900 via-purple-900 to-black min-h-screen text-white overflow-hidden">
  <!-- Game Loading Screen -->
  <div id="loading-screen" class="fixed inset-0 flex items-center justify-center bg-black z-50">
    <div class="text-center">
      <h2 class="text-5xl font-extrabold mb-8 text-purple-400 tracking-wider">RIFFLE</h2>
      <div class="w-64 h-2 bg-gray-800 rounded-full mx-auto overflow-hidden">
        <div id="loading-progress" class="h-full bg-gradient-to-r from-purple-500 to-indigo-600 rounded-full" style="width: 0%"></div>
      </div>
      <p class="mt-4 text-purple-300" id="loading-text">Loading music tracks...</p>
    </div>
  </div>

  <!-- Top Navigation -->
  <nav class="relative z-10 px-4 pt-4 flex justify-between items-center">
    <button id="mainMenuBtn" type="button" class="flex items-center text-white hover:text-purple-300 transition bg-black bg-opacity-60 border border-purple-600 rounded-lg px-3 py-2 shadow-lg hover:scale-105 transform transition-all duration-300 cursor-pointer z-[1000]">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 17l-5-5m0 0l5-5m-5 5h12" />
      </svg>
      Main Menu
    </button>
    <div class="text-white text-xl font-bold flex items-center">
      <span id="game-mode-title">Marathon Mode</span>
      <span id="round-info" class="ml-4 text-sm bg-purple-800 px-3 py-1 rounded-full">Question 1/10</span>
    </div>
  </nav>

  <!-- Game Container -->
  <main class="relative z-10 flex flex-col items-center justify-center min-h-[80vh] px-4 py-8">
    <!-- Audio Player (Hidden) -->
    <audio id="music-player" class="hidden"></audio>

    <!-- Score Display -->
    <div class="absolute top-6 right-6 flex items-center">
      <div class="bg-black bg-opacity-50 px-4 py-2 rounded-lg flex items-center">
        <!-- Player Avatar -->
        <div class="h-8 w-8 rounded-full bg-gradient-to-br from-purple-500 to-indigo-600 p-1 mr-3 flex-shrink-0">
          <img id="player-avatar" src="src/img/avatars/avatar1.png" alt="Player Avatar" class="rounded-full">
        </div>
        
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-yellow-400 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" />
        </svg>
        <span id="current-score" class="text-xl font-bold">0</span>
        <span class="mx-1">/</span>
        <span id="max-score">10</span>
        
        <!-- Lives display for Marathon mode -->
        <div id="lives-display" class="ml-4 hidden">
          <div class="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-red-500 mr-1" fill="currentColor" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
            </svg>
            <span id="lives-count" class="text-md font-bold text-red-400">3</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Timer Bar (For VS modes) -->
    <div id="timer-container" class="w-full max-w-3xl mb-6">
      <div class="w-full h-3 bg-gray-800 rounded-full overflow-hidden">
        <div id="timer-bar" class="h-full bg-gradient-to-r from-red-500 to-yellow-500 progress-bar" style="width: 100%"></div>
      </div>
    </div>

    <!-- Album Art & Visualizer -->
    <div class="mb-10 relative">
      <div class="w-48 h-48 md:w-64 md:h-64 rounded-full bg-gradient-to-r from-purple-600 to-indigo-600 flex items-center justify-center pulse-animation">
        <div class="w-24 h-24 md:w-32 md:h-32 rounded-full bg-black flex items-center justify-center overflow-hidden">
          <!-- Audio Bar Visualizer -->
          <div id="music-visualizer" class="w-full h-full flex items-center justify-center">
            <div class="audio-bars-container flex items-center justify-center space-x-1 h-16">
              <!-- Audio bars will be created dynamically with JavaScript -->
            </div>
          </div>
        </div>
      </div>
      
      <!-- Duration Bar - Above the Disk (Higher position) -->
      <div id="music-duration-bar" class="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-12 w-48 h-3 z-20 flex justify-center items-center rounded-full overflow-hidden shadow-lg">
        <div id="music-progress" class="h-full bg-gradient-to-r from-purple-500 to-indigo-500" style="width: 100%"></div>
      </div>
    </div>

    <!-- Question -->
    <div class="text-center mb-8">
      <h2 id="question-text" class="text-3xl md:text-4xl font-bold mb-2 text-white">Which song is this track from?</h2>
      <p id="genre-info" class="text-lg text-purple-300">70's Rock</p>
    </div>

    <!-- Answer Options -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 w-full max-w-3xl">
      <button class="answer-btn bg-purple-900 bg-opacity-50 hover:bg-opacity-70 py-4 px-6 rounded-xl text-xl font-semibold transition duration-200 transform shadow-lg">Answer 1</button>
      <button class="answer-btn bg-purple-900 bg-opacity-50 hover:bg-opacity-70 py-4 px-6 rounded-xl text-xl font-semibold transition duration-200 transform shadow-lg">Answer 2</button>
      <button class="answer-btn bg-purple-900 bg-opacity-50 hover:bg-opacity-70 py-4 px-6 rounded-xl text-xl font-semibold transition duration-200 transform shadow-lg">Answer 3</button>
      <button class="answer-btn bg-purple-900 bg-opacity-50 hover:bg-opacity-70 py-4 px-6 rounded-xl text-xl font-semibold transition duration-200 transform shadow-lg">Answer 4</button>
    </div>

    <!-- Players (For multiplayer modes) -->
    <div id="players-container" class="w-full max-w-3xl mt-10 hidden">
      <h3 class="text-xl font-bold mb-3 text-purple-300">Players</h3>
      <div class="bg-black bg-opacity-50 rounded-xl p-4">
        <div id="players-list" class="grid grid-cols-2 md:grid-cols-4 gap-4">
          <!-- Player cards will be generated dynamically -->
        </div>
      </div>
    </div>
  </main>

  <!-- Round Completion Screen (Hidden by default) -->
  <div id="round-completion" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 hidden">
    <div class="bg-gradient-to-br from-purple-900 to-indigo-900 rounded-2xl p-8 max-w-2xl w-full mx-4 relative shadow-2xl transform transition-all duration-500 scale-100">
      <div class="absolute -top-16 left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-yellow-500 to-yellow-300 rounded-full p-4 shadow-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-purple-900" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      </div>
      
      <h2 class="text-3xl font-extrabold mb-2 text-center text-white mt-8">Round Complete!</h2>
      
      <!-- Album cover display -->
      <div class="mb-4 flex justify-center">
        <div class="w-32 h-32 md:w-40 md:h-40 rounded-lg overflow-hidden shadow-lg">
          <img id="album-cover-display" src="https://via.placeholder.com/200" alt="Album Cover" class="w-full h-full object-cover">
        </div>
      </div>
      
      <div class="mb-4 text-center">
        <div id="round-result" class="text-4xl font-bold text-yellow-400 mb-2">Correct!</div>
        <p id="round-message" class="text-lg text-purple-300">You're on fire! Keep it up!</p>
      </div>
      <div class="text-center mb-4">
        <div class="text-sm text-purple-200" id="song-info"></div>
      </div>
      
      <!-- Current Round Scoreboard -->
      <div class="mb-6">
        <h3 class="text-xl font-bold mb-3 text-purple-300">Current Standings</h3>
        <div class="bg-black bg-opacity-50 rounded-xl p-4">
          <table class="w-full text-white">
            <thead>
              <tr class="border-b border-purple-800">
                <th class="py-2 text-left">Player</th>
                <th class="py-2 text-right">Score</th>
                <th class="py-2 text-right">This Round</th>
              </tr>
            </thead>
            <tbody id="round-score-table">
              <!-- Player scores will be added dynamically -->
            </tbody>
          </table>
        </div>
      </div>
      
      <div class="flex justify-center">
        <button id="next-round-btn" class="bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 text-white font-bold py-3 px-8 rounded-lg transform transition hover:scale-105">
          Next Round
        </button>
      </div>
    </div>
  </div>

  <!-- Results Modal (Hidden by default) -->
  <div id="results-modal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50 hidden overflow-y-auto py-10">
    <div id="results-content" class="bg-gradient-to-b from-gray-900 to-purple-900 rounded-2xl p-8 max-w-2xl w-full mx-4 relative shadow-2xl transform transition-all duration-500 scale-95 opacity-0 border-2 border-purple-500/30">
      <!-- Trophy icon at the top -->
      <div class="absolute -top-16 left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-yellow-400 to-yellow-200 rounded-full p-4 shadow-xl">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-14 w-14 text-purple-900" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
        </svg>
      </div>
      
      <h2 class="text-4xl font-extrabold mb-4 text-center text-white mt-6 animate-pulseGrow">Game Over!</h2>
      
      <div class="mb-4 text-center">
        <div class="text-6xl font-bold text-yellow-400 mb-2 animate-pulseGrow" id="final-score">0/10</div>
        <p class="text-xl font-bold text-center text-purple-300 my-4 animate-pulseGrow" id="score-message">Great game!</p>
      </div>
      
      <!-- Animated Stars background -->
      <div class="absolute inset-0 overflow-hidden pointer-events-none z-0">
        <div class="stars-container"></div>
      </div>
      
      <!-- Game Statistics -->
      <div id="game-stats" class="mb-6">
        <!-- Stats will be added dynamically -->
      </div>
      
      <!-- Final Scoreboard -->
      <div id="final-scoreboard" class="mb-8">
        <h3 class="text-xl font-bold mb-3 text-purple-300">Final Scoreboard</h3>
        <div class="bg-black bg-opacity-60 rounded-xl p-4 border border-purple-800/30">
          <table class="w-full text-white">
            <thead>
              <tr class="border-b border-purple-800">
                <th class="py-2 text-left">Player</th>
                <th class="py-2 text-center">Score</th>
                <th class="py-2 text-right">Accuracy</th>
              </tr>
            </thead>
            <tbody id="score-table-body" class="text-lg">
              <!-- Scores will be added dynamically -->
            </tbody>
          </table>
        </div>
      </div>
      
      <!-- Tracks Summary -->
      <div id="played-tracks-summary" class="mb-8">
        <!-- Recent tracks will be added dynamically -->
      </div>
      
      <div class="flex flex-col sm:flex-row gap-4 justify-center mt-6">
        <button id="replay-btn" class="bg-gradient-to-r from-purple-700 to-purple-600 hover:from-purple-600 hover:to-purple-500 text-white font-bold py-3 px-8 rounded-lg transform transition hover:scale-105 shadow-lg animate-fadeInUp" style="animation-delay: 0.6s">
          <div class="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clip-rule="evenodd" />
            </svg>
            Play Again
          </div>
        </button>
        <button id="menu-btn" class="bg-gradient-to-r from-indigo-700 to-indigo-600 hover:from-indigo-600 hover:to-indigo-500 text-white font-bold py-3 px-8 rounded-lg transform transition hover:scale-105 shadow-lg animate-fadeInUp" style="animation-delay: 0.7s">
          <div class="flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z" clip-rule="evenodd" />
            </svg>
            Return to Main Menu
          </div>
        </button>
      </div>
    </div>
  </div>

  <!-- Game Logic -->
  <script type="module">
    import { getAllGenres, getRandomTrackFromGenre, resetPlayedTracks } from "../src/js/music.js";
    
    // Game variables
    let score = 0;
    let currentRound = 0;
    let totalRounds = 10;
    let timeLimit = 15; // Seconds
    let lives = 3; // Default lives for Marathon mode
    let remainingLives = 3;
    let timer = null;
    let correctAnswer = '';
    let currentTrack = null;
    let gameMode = '';
    let players = [];
    let answerSelected = false; // Track if an answer was selected during the current round
    let settings = {
      categories: [],
      questionType: 'mixed',
      previewLength: 10,
      lives: '3'
    };
    
    // DOM elements
    const musicPlayer = document.getElementById('music-player');
    const timerBar = document.getElementById('timer-bar');
    // Removed references to play/pause icons since they're no longer in the DOM
    const answerButtons = document.querySelectorAll('.answer-btn');
    
    // Initialize game
    // Function to initialize audio API in the browser before use
    async function initializeAudio() {
      try {
        // Create and start a temporary audio context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Try to resume if 'suspended'
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
        
        // Play a temporary silent sound - very short
        const silentBuffer = audioContext.createBuffer(1, 1, 22050);
        const source = audioContext.createBufferSource();
        source.buffer = silentBuffer;
        source.connect(audioContext.destination);
        source.start(0);
        
        return audioContext;
      } catch (e) {
        return null;
      }
    }
    
    document.addEventListener('DOMContentLoaded', async () => {
      // Get game mode and settings
      gameMode = new URLSearchParams(window.location.search).get('mode') || 'solo';
      loadGameSettings();
      
      // Reset track history when starting a new game
      resetPlayedTracks();
      
      // Set up UI based on game mode
      setupGameMode();
      
      // Try to initialize the audio system in advance
      await initializeAudio();
      
      // Simulate loading
      simulateLoading().then(() => {
        // Start the first round
        startNewRound();
        
        // Set up event listeners
        setupEventListeners();
      });
    });
    
    // Load settings from localStorage
    function loadGameSettings() {
      const savedSettings = localStorage.getItem('riffleGameSettings');
      if (savedSettings) {
        const parsed = JSON.parse(savedSettings);
        settings = {
          ...settings,
          ...parsed
        };
        
        if (settings.rounds && settings.rounds !== 'unlimited') {
          totalRounds = parseInt(settings.rounds);
          document.getElementById('max-score').textContent = totalRounds;
        }
        
        if (settings.timeLimit) {
          timeLimit = settings.timeLimit;
        }
        
        // Load lives setting for Marathon mode
        if (settings.lives && gameMode === 'solo') {
          lives = settings.lives === 'unlimited' ? Infinity : parseInt(settings.lives);
          remainingLives = lives;
        }
        
        // Load avatar if available
        const avatar = settings.avatar || localStorage.getItem('selectedAvatar') || 'avatar1';
        document.getElementById('player-avatar').src = `src/img/avatars/${avatar}.png`;
        
        document.getElementById('game-mode-title').textContent = {
          'solo': 'Marathon Mode',
          'coop': 'Cooperative Mode',
          'versus': 'Solo VS Mode',
          'team': 'Team VS Mode',
          'chaos': 'Chaos Mode',
          'custom': 'Custom Mode'
        }[gameMode] || 'Riffle';
      }
    }
    
    // Setup game mode specific UI
    function setupGameMode() {
      // Show/hide UI elements based on game mode
      if (gameMode === 'solo') { // Marathon mode
        document.getElementById('timer-container').classList.add('hidden');
        document.getElementById('players-container').classList.add('hidden');
        
        // For marathon mode, if rounds is unlimited, hide round info
        if (settings.rounds === 'unlimited') {
          document.getElementById('round-info').classList.add('hidden');
        }
        
        // Show lives for Marathon mode
        const livesDisplay = document.getElementById('lives-display');
        const livesCount = document.getElementById('lives-count');
        
        if (livesDisplay && livesCount) {
          livesDisplay.classList.remove('hidden');
          
          // Set the appropriate number of lives
          if (lives === Infinity) {
            livesCount.textContent = '∞';
          } else {
            livesCount.textContent = remainingLives;
          }
        }
      } else {
        // VS modes show timer
        document.getElementById('timer-container').classList.remove('hidden');
        // Team/Versus/Coop modes show players
        if (['versus', 'team', 'coop'].includes(gameMode)) {
          document.getElementById('players-container').classList.remove('hidden');
          // Generate mock players for demo
          generateMockPlayers();
        }
      }
    }
    
    // Generate mock players for multiplayer demo
    function generateMockPlayers() {
      const playerNames = ['Sen', 'Ahmet', 'Zeynep', 'Burak'];
      const playerColors = ['purple-500', 'blue-500', 'green-500', 'yellow-500'];
      const playersList = document.getElementById('players-list');
      
      playersList.innerHTML = '';
      
      playerNames.forEach((name, i) => {
        // For the player (i === 0), use their selected avatar
        const avatar = i === 0 ? 
          (settings.avatar || localStorage.getItem('selectedAvatar') || 'avatar1') : 
          `avatar${Math.floor(Math.random() * 4) + 1}`;
        
        players.push({
          name,
          score: 0,
          color: playerColors[i],
          avatar: avatar
        });
        
        const playerCard = document.createElement('div');
        playerCard.className = `bg-gray-800 bg-opacity-70 rounded-lg p-3 text-center border-l-4 border-${playerColors[i]}`;
        playerCard.innerHTML = `
          <div class="mb-2 flex justify-center">
            <div class="h-10 w-10 rounded-full bg-gradient-to-br from-${playerColors[i]} to-indigo-600 p-1">
              <img src="src/img/avatars/${avatar}.png" alt="${name}'s Avatar" class="rounded-full">
            </div>
          </div>
          <div class="font-bold ${i === 0 ? 'text-white' : 'text-gray-300'}">${name}</div>
          <div class="text-2xl font-bold text-${playerColors[i]}">0</div>
        `;
        playersList.appendChild(playerCard);
      });
    }
    
    // Simulate loading
    function simulateLoading() {
      return new Promise(resolve => {
        const loadingProgress = document.getElementById('loading-progress');
        const loadingText = document.getElementById('loading-text');
        const loadingScreen = document.getElementById('loading-screen');
        
        let progress = 0;
        const interval = setInterval(() => {
          progress += Math.random() * 15;
          if (progress > 100) progress = 100;
          
          loadingProgress.style.width = `${progress}%`;
          
          if (progress < 30) {
            loadingText.textContent = 'Loading music tracks...';
          } else if (progress < 60) {
            loadingText.textContent = 'Preparing categories...';
          } else if (progress < 90) {
            loadingText.textContent = 'Almost ready...';
          } else {
            loadingText.textContent = 'Starting!';
          }
          
          if (progress === 100) {
            clearInterval(interval);
            setTimeout(() => {
              loadingScreen.classList.add('opacity-0');
              loadingScreen.style.transition = 'opacity 0.5s ease-out';
              setTimeout(() => {
                loadingScreen.classList.add('hidden');
                resolve();
              }, 500);
            }, 500);
          }
        }, 200);
      });
    }
    
    // Function to clean song titles (remove "Remastered" and similar tags)
    function cleanSongTitle(title) {
      if (!title) return title;
      // Remove (Remastered), (Remastered yyyy), [Remastered], etc.
      return title.replace(/\s*[\(\[](?:Remastered|Re-?master|Re-?issue).*?[\)\]]/gi, '')
                  .replace(/\s{2,}/g, ' ')  // Replace multiple spaces with a single space
                  .trim();  // Remove any leading/trailing spaces
    }
    
    // Start a new round
    async function startNewRound() {
      // Check if we've reached the round limit
      if (settings.rounds !== 'unlimited' && currentRound >= totalRounds) {
        // Game is complete, show the final results
        showGameOverScreen();
        return;
      }
      
      // Remove any "Continue" buttons from previous rounds
      const timeoutBtn = document.getElementById('timeout-next-btn');
      if (timeoutBtn && timeoutBtn.parentNode) {
        timeoutBtn.parentNode.removeChild(timeoutBtn);
      }
      
      currentRound++;
      
      // Update round info
      if (settings.rounds !== 'unlimited') {
        document.getElementById('round-info').textContent = `Question ${currentRound}/${totalRounds}`;
      } else {
        document.getElementById('round-info').textContent = `Question ${currentRound}`;
      }
      
      // Reset UI
      resetUI();
      
      try {
        // Get random track
        let track;
        if (settings.categories && settings.categories.length > 0) {
          // Choose random category from selected ones
          const categoryId = settings.categories[Math.floor(Math.random() * settings.categories.length)];
          track = await getRandomTrackFromGenre(categoryId);
        } else {
          // Default to random genre
          track = await getRandomTrackFromGenre('rock_80s');
        }
        
        currentTrack = track;
        
        // Set audio source
        musicPlayer.src = track.preview;
        musicPlayer.volume = 0.8;
        
        // Prepare question based on settings
        let questionType = settings.questionType;
        if (questionType === 'mixed') {
          questionType = Math.random() > 0.5 ? 'song' : 'artist';
        }
        
        // Set question text and correct answer
        const questionText = document.getElementById('question-text');
        const genreInfo = document.getElementById('genre-info');
        
        if (questionType === 'song') {
          questionText.textContent = 'Which song is this?';
          // Clean the title before setting it as the correct answer
          track.cleanTitle = cleanSongTitle(track.title);
          correctAnswer = track.cleanTitle;
        } else if (questionType === 'artist') {
          questionText.textContent = 'Which artist/band performs this track?';
          correctAnswer = track.artist;
        } else if (questionType === 'guitarist') {
          questionText.textContent = 'Who is the guitarist for this track?';
          correctAnswer = track.guitarist || track.artist; // Fallback if guitarist info not available
        }
        
        genreInfo.textContent = track.genreName || 'Rock/Metal';
        
        // Generate answer options
        generateAnswerOptions();
        
        // Start music automatically in each round and enhance with visual effects
        // Start music with a short delay
        setTimeout(() => {
          // First show preparation effect
          const pulseEffect = document.createElement('div');
          pulseEffect.className = 'fixed inset-0 bg-purple-900 bg-opacity-10 z-20';
          document.body.appendChild(pulseEffect);
          
          // Show and remove effect
          pulseEffect.animate([
            { opacity: 0.2 },
            { opacity: 0 }
          ], {
            duration: 800,
            easing: 'ease-out'
          }).onfinish = () => pulseEffect.remove();
          
          // Then start the music
          playMusic();
          
          // Highlight album
          const albumContainer = document.querySelector('.pulse-animation');
          if (albumContainer) {
            albumContainer.classList.add('z-10');
            albumContainer.style.boxShadow = '0 0 30px rgba(139, 92, 246, 0.5)';
          }
          
          // Create music playback indicator
          // Note: Music playback indicator is created in the playMusic function
          // No need to create a separate indicator in this section
          
          // Start timer for VS modes
          if (gameMode !== 'solo') {
            startTimer();
          }
          // Start music duration timer (for all modes)
        }, 1000);
        
      } catch (error) {
        console.error('Error loading track:', error);
        alert('An error occurred while loading the track. Please try again.');
      }
    }
    
    // Generate answer options
    function generateAnswerOptions() {
      // Enhanced fake options organized by era and genre
      const enhancedOptions = {
        'song': {
          '60s': ['House Of The Rising Sun', 'Purple Haze', 'Born To Be Wild', 'Light My Fire', 'Fortunate Son', 'Good Vibrations', 'Satisfaction', 'Gimme Shelter', 'White Rabbit', 'All Along The Watchtower'],
          '70s': ['Stairway To Heaven', 'Hotel California', 'Smoke On The Water', 'Bohemian Rhapsody', 'Black Dog', 'Paranoid', 'Another Brick In The Wall', 'Dream On', 'Layla', 'Free Bird'],
          '80s': ['Sweet Child O\' Mine', 'Enter Sandman', 'Back in Black', 'Crazy Train', 'Run To The Hills', 'Breaking The Law', 'You Give Love A Bad Name', 'Welcome To The Jungle', 'Master of Puppets', 'Jump'],
          '90s': ['Nothing Else Matters', 'Smells Like Teen Spirit', 'Black Hole Sun', 'Enter Sandman', 'One', 'Sober', 'Alive', 'Jeremy', 'Zombie', 'Basket Case'],
          '00s': ['Chop Suey!', 'In The End', 'Toxicity', 'Seven Nation Army', 'Boulevard of Broken Dreams', 'Numb', 'The Pretender', 'Mr. Brightside', 'Last Resort', 'Diary of Jane']
        },
        'artist': {
          '60s': ['The Doors', 'Jimi Hendrix', 'The Beatles', 'The Rolling Stones', 'Jefferson Airplane', 'Steppenwolf', 'Cream', 'The Who', 'The Animals', 'Creedence Clearwater Revival'],
          '70s': ['Led Zeppelin', 'Black Sabbath', 'Deep Purple', 'Queen', 'Pink Floyd', 'AC/DC', 'Aerosmith', 'Lynyrd Skynyrd', 'The Eagles', 'Kiss'],
          '80s': ['Metallica', 'Guns N\' Roses', 'Iron Maiden', 'Judas Priest', 'Motley Crue', 'Van Halen', 'Bon Jovi', 'Def Leppard', 'Megadeth', 'Scorpions'],
          '90s': ['Nirvana', 'Pearl Jam', 'Soundgarden', 'Alice In Chains', 'Rage Against The Machine', 'Tool', 'Red Hot Chili Peppers', 'Radiohead', 'The Cranberries', 'Green Day'],
          '00s': ['System Of A Down', 'Linkin Park', 'Disturbed', 'The White Stripes', 'Slipknot', 'Evanescence', 'Foo Fighters', 'The Killers', 'Papa Roach', 'Breaking Benjamin']
        },
        'guitarist': {
          '60s': ['Jimi Hendrix', 'Keith Richards', 'Eric Clapton', 'Pete Townshend', 'Jimmy Page', 'Jeff Beck', 'David Gilmour', 'Jorma Kaukonen', 'John Fogerty', 'George Harrison'],
          '70s': ['Jimmy Page', 'Tony Iommi', 'Ritchie Blackmore', 'Brian May', 'David Gilmour', 'Angus Young', 'Joe Perry', 'Allen Collins', 'Don Felder', 'Ace Frehley'],
          '80s': ['Kirk Hammett', 'Slash', 'Dave Murray', 'K.K. Downing', 'Mick Mars', 'Eddie Van Halen', 'Richie Sambora', 'Phil Collen', 'Marty Friedman', 'Rudolf Schenker'],
          '90s': ['Kurt Cobain', 'Mike McCready', 'Kim Thayil', 'Jerry Cantrell', 'Tom Morello', 'Adam Jones', 'John Frusciante', 'Jonny Greenwood', 'Billie Joe Armstrong', 'Noel Gallagher'],
          '00s': ['Daron Malakian', 'Brad Delson', 'Dan Donegan', 'Jack White', 'Jim Root', 'Ben Moody', 'Dave Grohl', 'Matthew Bellamy', 'Zacky Vengeance', 'Mark Tremonti']
        },
        'turkish': {
          'artist': ['Barış Manço', 'Erkin Koray', 'Cem Karaca', 'Murat Ses', 'Mor ve Ötesi', 'Duman', 'Pentagram/Mezarkabul', 'Hayko Cepkin', 'Kurban', 'Şebnem Ferah'],
          'song': ['Dönence', 'Yine Yalnızım', 'Resimdeki Gözyaşları', 'İşte Hendek İşte Deve', 'Bir Derdim Var', 'Senden Daha Güzel', 'Lions In A Cage', 'Bertaraf Et', 'Yirmi', 'Can Kırıkları']
        }
      };
      
      const questionType = settings.questionType === 'mixed' ? 
        (correctAnswer === (currentTrack.cleanTitle || currentTrack.title) ? 'song' : 'artist') : settings.questionType;
      
      // Determine the era and genre based on current track
      let era = '80s'; // Default era if we can't determine
      let genre = 'rock';
      
      // Try to determine era from track genre
      if (currentTrack.genreName) {
        const genreLower = currentTrack.genreName.toLowerCase();
        if (genreLower.includes('60')) era = '60s';
        else if (genreLower.includes('70')) era = '70s';
        else if (genreLower.includes('80')) era = '80s';
        else if (genreLower.includes('90')) era = '90s';
        else if (genreLower.includes('00') || genreLower.includes('2000')) era = '00s';
        
        // Check if it's Turkish music
        if (genreLower.includes('turkish') || genreLower.includes('anatolia')) {
          genre = 'turkish';
        }
      }
      
      let options = [correctAnswer];
      
      // Add appropriate fake options based on era and genre
      while (options.length < 4) {
        let optionPool;
        
        if (genre === 'turkish' && enhancedOptions.turkish[questionType]) {
          optionPool = enhancedOptions.turkish[questionType];
        } else if (enhancedOptions[questionType] && enhancedOptions[questionType][era]) {
          optionPool = enhancedOptions[questionType][era];
        } else {
          // Fallback to any era if specific era not available
          const allEras = Object.values(enhancedOptions[questionType] || {}).flat();
          optionPool = allEras.length > 0 ? allEras : enhancedOptions.artist['80s']; // Default fallback
        }
        
        const randomOption = optionPool[Math.floor(Math.random() * optionPool.length)];
        
        if (!options.includes(randomOption)) {
          options.push(randomOption);
        }
      }
      
      // Shuffle options
      options = shuffleArray(options);
      
      // Set button texts
      answerButtons.forEach((btn, i) => {
        btn.textContent = options[i];
        btn.dataset.answer = options[i];
      });
    }
    
    // Reset UI for new round
    function resetUI() {
      // Eski round'dan kalan timeout'u temizle
      if (window.riffleTimeout) {
        clearTimeout(window.riffleTimeout);
        window.riffleTimeout = null;
      }
      // Eski round'dan kalan timeout'u temizle
      if (window.riffleTimeout) {
        clearTimeout(window.riffleTimeout);
        window.riffleTimeout = null;
      }
      // Prevent double timeout logic
      window.timeoutHandled = false;
      // Reset answer selection tracking
      answerSelected = false;
      
      // Reset timer
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      timerBar.style.width = '100%';
      timerBar.style.backgroundColor = '';
      timerBar.textContent = '';
      
      // Reset buttons
      answerButtons.forEach(btn => {
        btn.classList.remove('correct', 'wrong', 'selected', 'timeout-correct');
        btn.disabled = false;
      });
      
      // Reset music player
      musicPlayer.pause();
      musicPlayer.currentTime = 0;
      
      // Reset duration bar
      const musicProgress = document.getElementById('music-progress');
      if (musicProgress) {
        musicProgress.style.width = '100%';
      }
      
      // Clear existing timer
      if (window.musicProgressTimer) {
        clearInterval(window.musicProgressTimer);
        window.musicProgressTimer = null;
      }
      
      // Create music visualizer (but don't start it yet)
      createMusicVisualizer();
      stopMusicVisualizer();
    }
    
    // Start timer for VS modes
    function startTimer() {
      window.timeoutHandled = false;
      let timeLeft = timeLimit;
      timerBar.style.width = '100%';
      timerBar.style.backgroundColor = '';
      timerBar.textContent = '';

      // Clear any existing timer to prevent multiple timers running
      if (timer) {
        clearInterval(timer);
        timer = null;
      }

      timer = setInterval(() => {
        timeLeft -= 0.1;
        const percentage = (timeLeft / timeLimit) * 100;
        timerBar.style.width = `${percentage}%`;
        timerBar.textContent = '';

        if (timeLeft <= 0) {
          clearInterval(timer);
          timerBar.style.width = '100%';
          timerBar.style.backgroundColor = '#ef4444';
          timerBar.textContent = 'Süre Bitti';
          if (!answerSelected) handleTimeout(true); // Sadece şık seçilmediyse
        }
      }, 100);
    }
    
    // Handle timeout (no answer selected)
    function handleTimeout() {
      // Prevent double execution (e.g. from timer and music preview timeout)
      if (window.timeoutHandled || answerSelected) return;
      window.timeoutHandled = true;
      // The user didn't select an answer in time, count it as wrong
      // Show the correct answer with a special styling

      // First, add the special style for timeout-correct if not exists
      if (!document.getElementById('timeout-correct-style')) {
        const style = document.createElement('style');
        style.id = 'timeout-correct-style';
        style.textContent = `
          .timeout-correct {
            background: repeating-linear-gradient(
              45deg,
              rgba(74, 222, 128, 0.6),
              rgba(74, 222, 128, 0.6) 10px,
              rgba(74, 222, 128, 0.8) 10px,
              rgba(74, 222, 128, 0.8) 20px
            ) !important;
            color: #111 !important;
            font-weight: bold !important;
            border: 2px dashed #22c55e !important;
            animation: pulse-border 2s infinite;
          }
          @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
          }
        `;
        document.head.appendChild(style);
      }

      // Disable all buttons
      answerButtons.forEach(btn => {
        btn.disabled = true;
        // Sadece hiç şık seçilmediyse ve timeout'tan gelindiyse çizgili yeşil göster
        if (!answerSelected && btn.dataset.answer === correctAnswer) {
          btn.classList.add('timeout-correct');
        } else if (btn.classList.contains('timeout-correct')) {
          // Eğer kullanıcı şık seçtiyse ve bu class yanlışlıkla kaldıysa temizle
          btn.classList.remove('timeout-correct');
        }
      });

      // For Marathon mode, decrease lives if applicable - same as wrong answer
      if (gameMode === 'solo' && lives !== Infinity) {
        remainingLives--;
        document.getElementById('lives-count').textContent = remainingLives;
      }

      // Süre bittiğinde round hemen bitsin, bar 1.2sn kalsın sonra round ekranı gelsin
      setTimeout(() => {
        timerBar.style.width = '100%';
        timerBar.style.backgroundColor = '';
        timerBar.textContent = '';
        checkGameProgress();
      }, 1200);
    }
    
    // Play music preview
    function playMusic() {
      // Add visual effects before music starts
      // We're using createVisualizer and animateVisualizer functions for the visualizer
      // no need to create a separate one here
      
      // Add enhanced effect to album cover
      const albumCover = document.querySelector('.album-cover');
      if (albumCover) {
        // Add glowing border effect
        albumCover.style.transition = 'all 0.5s ease-in-out';
        albumCover.style.transform = 'scale(1.05)';
        albumCover.style.boxShadow = '0 0 20px rgba(139, 92, 246, 0.7)';
        
        setTimeout(() => {
          albumCover.style.transform = 'scale(1)';
          albumCover.style.boxShadow = '0 8px 16px rgba(0, 0, 0, 0.5)';
        }, 500);
      }
      
      // A more robust approach to start music playback
      
      // Create an audio channel and play (usually requires permission)
      const attemptAutoplay = async () => {
        try {
          // First try muted playback - usually allowed by browsers
          musicPlayer.muted = true;
          await musicPlayer.play();
          
          // Success, we can unmute now
          setTimeout(() => {
            musicPlayer.muted = false;
          }, 100);
          
          // Start duration bar
          startMusicDurationBar();
          
          // Start music visualizer
          startMusicVisualizer();
        } catch (e) {
          // Alternative solution: wait for user interaction on the page
          const handlePageInteraction = () => {
            musicPlayer.muted = false;
            musicPlayer.play();
            
            // Remove event listeners
            document.removeEventListener('click', handlePageInteraction);
            document.removeEventListener('keydown', handlePageInteraction);
          };
          
          // Listen for any interaction on the page
          document.addEventListener('click', handlePageInteraction);
          document.addEventListener('keydown', handlePageInteraction);
        }
      };
      
      // Try autoplay
      attemptAutoplay();
      
      // Start the duration bar
      startMusicDurationBar();
      
      // Start music visualizer
      startMusicVisualizer();
      
      // After preview length, indicate that preview time is up
      window.riffleTimeout = setTimeout(() => {
        if (!answerSelected && !window.timeoutHandled) {
          handleTimeout();
        }
      }, settings.previewLength * 1000);
      
      // For VS mode we need an extra button for navigation
      if (gameMode !== 'solo') {
        setTimeout(() => {
          if (!answerSelected) {
            // Add a 'Next' button to allow moving forward without auto-showing the round completion screen
            const questionContainer = document.querySelector('.question-container');
            if (questionContainer && !document.getElementById('manual-next-btn')) {
              const nextBtn = document.createElement('button');
              nextBtn.id = 'manual-next-btn';
              nextBtn.className = 'bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded mt-4 transition duration-300';
              nextBtn.textContent = 'Continue';
              nextBtn.onclick = () => {
                if (nextBtn.parentNode) {
                  nextBtn.parentNode.removeChild(nextBtn);
                }
                showRoundCompletionScreen(false);
              };
              questionContainer.appendChild(nextBtn);
            }
          }
        }, settings.previewLength * 1000 + 100); // Add slight delay after the first timeout
      }
    }
    
    // Toggle play/pause - Updated version for autoplay
    function togglePlayPause() {
      if (musicPlayer.paused) {
        playMusic(); // Use enhanced playMusic function
      } else {
        musicPlayer.pause();
        
        // Stop music visualizer
        stopMusicVisualizer();
      }
    }
    
    // Audio bar visualizer creation function
    function createMusicVisualizer() {
      const container = document.getElementById('music-visualizer');
      if (!container) return;
      
      // Get the audio-bars-container inside the container
      let barsContainer = container.querySelector('.audio-bars-container');
      if (!barsContainer) {
        barsContainer = document.createElement('div');
        barsContainer.className = 'audio-bars-container flex items-center justify-center space-x-1';
        container.appendChild(barsContainer);
      }
      
      // Clear the container
      barsContainer.innerHTML = '';
      
      // Number of bars
      const barCount = 7;
      
      // Create bars
      for (let i = 0; i < barCount; i++) {
        const bar = document.createElement('div');
        bar.className = 'audio-bar';
        barsContainer.appendChild(bar);
      }
    }
    
    // Start audio bar visualizer animation
    function startMusicVisualizer() {
      const bars = document.querySelectorAll('.audio-bar');
      if (!bars.length) return;
      
      bars.forEach((bar, index) => {
        bar.classList.add('active');
        // Different animation delay for each bar
        bar.style.animationDelay = `${index * 0.1}s`;
      });
      
      // ID for animation frame
      if (window.audioAnimationFrameId) {
        cancelAnimationFrame(window.audioAnimationFrameId);
      }
      
      // Real audio visualizer effect with random heights
      const animateBars = () => {
        if (musicPlayer.paused) return;
        
        bars.forEach(bar => {
          if (Math.random() > 0.5) {
            const height = Math.random() * 10 + 5; // 5px - 15px
            bar.style.height = `${height}px`;
          }
        });
        
        window.audioAnimationFrameId = requestAnimationFrame(animateBars);
      };
      
      window.audioAnimationFrameId = requestAnimationFrame(animateBars);
    }
    
    // Stop audio bar visualizer animation
    function stopMusicVisualizer() {
      if (window.audioAnimationFrameId) {
        cancelAnimationFrame(window.audioAnimationFrameId);
      }
      
      const bars = document.querySelectorAll('.audio-bar');
      if (!bars.length) return;
      
      bars.forEach(bar => {
        bar.classList.remove('active');
        bar.style.animation = '';
        bar.style.height = '5px'; // Set to short state
      });
    }
    
    // Function for the duration bar
    function startMusicDurationBar() {
      const musicProgress = document.getElementById('music-progress');
      musicProgress.style.width = '100%';
      
      // Timer for music playback duration
      let musicDuration = settings.previewLength || 10; // Default 10 seconds
      let timeElapsed = 0;
      
      // Clear existing timer if any
      if (window.musicProgressTimer) {
        clearInterval(window.musicProgressTimer);
      }
      
      window.musicProgressTimer = setInterval(() => {
        if (!musicPlayer.paused) {
          timeElapsed += 0.1;
          const percentage = 100 - ((timeElapsed / musicDuration) * 100);
          
          // Update duration bar
          if (musicProgress) {
            musicProgress.style.width = `${percentage}%`;
          }
          
          // Has time expired?
          if (timeElapsed >= musicDuration) {
            clearInterval(window.musicProgressTimer);
            // Keep music playing but set progress bar to 100%
            if (musicProgress) {
              musicProgress.style.width = '100%';
            }
            // Do not stop music or visualizer
            // We'll let the user make their selection at their own pace
          }
        }
      }, 100);
      
      // Return timer reference
      return window.musicProgressTimer;
    }
    
    // Handle answer selection
    function handleAnswerClick(e) {
      const selectedButton = e.currentTarget;
      const selectedAnswer = selectedButton.dataset.answer;
      
      // Mark that an answer was selected
      answerSelected = true;
      window.timeoutHandled = true; // Kullanıcı şık seçtiyse timeout asla çalışmasın
      
      // Stop timer
      if (timer) clearInterval(timer);
      
      // Stop duration bar timer
      if (window.musicProgressTimer) {
        clearInterval(window.musicProgressTimer);
      }
      
      // Mark button as selected
      selectedButton.classList.add('selected');
      
      // Disable all buttons
      answerButtons.forEach(btn => {
        btn.disabled = true;
      });
      
      // Check if answer is correct
      const isCorrect = selectedAnswer === correctAnswer;
      
      if (isCorrect) {
        selectedButton.classList.add('correct');
        score++;
        document.getElementById('current-score').textContent = score;
        
        // Create confetti effect for correct answer
        createConfetti();
      } else {
        selectedButton.classList.add('wrong');
        
        // Show correct answer
        answerButtons.forEach(btn => {
          if (btn.dataset.answer === correctAnswer) {
            btn.classList.add('correct');
          }
        });
        
        // Reduce lives in Marathon mode
        if (gameMode === 'solo' && lives !== Infinity) {
          remainingLives--;
          document.getElementById('lives-count').textContent = remainingLives;
          
          // Visual effect for losing a life
          const livesDisplay = document.getElementById('lives-display');
          livesDisplay.classList.add('animate-pulse');
          setTimeout(() => {
            livesDisplay.classList.remove('animate-pulse');
          }, 1000);
        }
      }
      
      // Music continues playing, we no longer stop it
      // Visualizer will also continue to work
      
      // Update player score in multiplayer
      if (['versus', 'team', 'coop'].includes(gameMode)) {
        updatePlayerScore(0, isCorrect ? 1 : 0); // Always update player 0 (user) for demo
      }
      
      // Wait a moment and continue
      setTimeout(checkGameProgress, 2000);
    }
    
    // Update player score in UI
    function updatePlayerScore(playerIndex, points) {
      if (players[playerIndex]) {
        players[playerIndex].score += points;
        
        const playerElements = document.querySelectorAll('#players-list > div');
        if (playerElements[playerIndex]) {
          const scoreElement = playerElements[playerIndex].querySelector('div:last-child');
          if (scoreElement) {
            scoreElement.textContent = players[playerIndex].score;
          }
        }
      }
    }
    
    // Check if game should continue or end
    function checkGameProgress() {
      // For Marathon mode, check if player ran out of lives
      if (gameMode === 'solo' && lives !== Infinity && remainingLives <= 0) {
        // Game over due to running out of lives
        showRoundCompletionScreen(true); // true indicates game over
        return;
      }
      
      // Show the round completion screen regardless of whether the game continues or ends
      showRoundCompletionScreen();
    }
    
    // Show the round completion screen with current standings - Improved and faster version
    function showRoundCompletionScreen(isGameOver = false) {
      // Allow music to continue playing
      // We only stop visualizer if music has naturally ended
      if (musicPlayer.paused) {
        stopMusicVisualizer();
      }
      
      const roundCompletion = document.getElementById('round-completion');
      const roundResult = document.getElementById('round-result');
      const roundMessage = document.getElementById('round-message');
      const scoreTable = document.getElementById('round-score-table');
      const nextRoundBtn = document.getElementById('next-round-btn');
      const albumCoverDisplay = document.getElementById('album-cover-display');
      const songInfo = document.getElementById('song-info');
      
      // No confetti effect for round completion screen (only on final results)
      
      // Display album cover and song info if available
      if (currentTrack && currentTrack.album && currentTrack.album.cover_medium) {
        albumCoverDisplay.src = currentTrack.album.cover_medium;
        const displayTitle = currentTrack.cleanTitle || cleanSongTitle(currentTrack.title);
        songInfo.textContent = `${displayTitle} by ${currentTrack.artist}`;
      } else if (currentTrack) {
        // Fallback if no album cover
        albumCoverDisplay.src = "https://via.placeholder.com/200/6D28D9/FFFFFF?text=Riffle";
        const displayTitle = currentTrack.cleanTitle || cleanSongTitle(currentTrack.title);
        songInfo.textContent = `${displayTitle} by ${currentTrack.artist}`;
      }
      
      // Set result message based on the last answer
      // Check if the user actually selected an answer
      const selectedAnswer = document.querySelector('.answer-btn.selected');
      const lastAnswerCorrect = selectedAnswer && selectedAnswer.classList.contains('correct');
      const timeoutOccurred = document.querySelector('.timeout-correct') !== null;
      
      if (!selectedAnswer && timeoutOccurred) {
        // No answer was selected and time expired - show special styling
        roundResult.textContent = 'Time\'s Up!';
        roundMessage.textContent = 'You didn\'t select an answer in time.';
        roundResult.classList.remove('text-yellow-400', 'text-blue-400');
        
        // Add text color without background styling
        roundResult.classList.add('text-red-400');
        // Remove any existing style
        roundResult.style.background = '';
        roundResult.style.padding = '';
        roundResult.style.borderRadius = '';
      } else if (lastAnswerCorrect) {
        // Reset any special styling
        roundResult.style.background = '';
        roundResult.style.padding = '';
        roundResult.style.borderRadius = '';
        
        roundResult.textContent = 'Correct!';
        
        // Different messages based on performance
        if (score / currentRound > 0.8) {
          roundMessage.textContent = 'You\'re on fire! Keep it up!';
        } else if (score / currentRound > 0.5) {
          roundMessage.textContent = 'Well done! You\'re doing great!';
        } else {
          roundMessage.textContent = 'Correct! Keep improving!';
        }
        
        roundResult.classList.remove('text-red-400');
        roundResult.classList.add('text-yellow-400');
        } else if (selectedAnswer) {
          // User selected an incorrect answer
          // Reset any special styling
          roundResult.style.background = '';
          roundResult.style.padding = '';
          roundResult.style.borderRadius = '';
          
          roundResult.textContent = 'Wrong Answer!';
          roundMessage.textContent = 'Better luck on the next one!';
          roundResult.classList.remove('text-yellow-400', 'text-blue-400');
          roundResult.classList.add('text-red-400');
        }
        // The case where no answer was selected is handled above
              // Update the score table
      scoreTable.innerHTML = '';
      
      if (['versus', 'team', 'coop'].includes(gameMode)) {
        // Show all players in multiplayer mode
        players.forEach(player => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td class="py-2">
              <div class="flex items-center">
                <div class="h-6 w-6 rounded-full bg-gradient-to-br from-${player.color} to-indigo-600 p-0.5 mr-2">
                  <img src="src/img/avatars/${player.avatar}.png" alt="${player.name}'s Avatar" class="rounded-full">
                </div>
                ${player.name}
              </div>
            </td>
            <td class="py-2 text-right">${player.score}</td>
            <td class="py-2 text-right">${player === players[0] && lastAnswerCorrect ? '+1' : '+0'}</td>
          `;
          scoreTable.appendChild(row);
        });
      } else if (gameMode === 'marathon' || gameMode === 'solo') {
        // Marathon mode - enhanced display for single player
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="py-2">
            <div class="flex items-center">
              <div class="h-6 w-6 rounded-full bg-gradient-to-br from-purple-500 to-indigo-600 p-0.5 mr-2">
                <img src="src/img/avatars/${settings.avatar || localStorage.getItem('selectedAvatar') || 'avatar1'}.png" alt="Your Avatar" class="rounded-full">
              </div>
              You
            </div>
          </td>
          <td class="py-2 text-center">${score}</td>
          <td class="py-2 text-right">
            ${lastAnswerCorrect ? '+1' : (timeoutOccurred && !selectedAnswer) ? 
            '<span class="bg-yellow-800 text-xs px-2 py-1 rounded-full">Missed</span>' : '+0'}
          </td>
        `;
        scoreTable.appendChild(row);
        
        // Add a second row with additional Marathon mode info
        const infoRow = document.createElement('tr');
        infoRow.innerHTML = `
          <td class="py-2 text-sm text-gray-400">Streak</td>
          <td class="py-2 text-center">
            ${lastAnswerCorrect 
              ? (currentRound > 1 ? 'Continues!' : 'Started!') 
              : (timeoutOccurred && !selectedAnswer) ? 'Timed Out!' : 'Broken!'}
          </td>
          <td class="py-2 text-right">
            <span class="inline-flex items-center bg-gray-800 rounded-full px-3 py-1 text-sm">
              <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                <path d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"></path>
              </svg>
              ${remainingLives}
            </span>
          </td>
        `;
        scoreTable.appendChild(infoRow);
      } else {
        // Other solo modes - standard display
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="py-2">You</td>
          <td class="py-2 text-right">${score}</td>
          <td class="py-2 text-right">${lastAnswerCorrect ? '+1' : '+0'}</td>
        `;
        scoreTable.appendChild(row);
      }
      
      // Update button text based on whether there are more rounds or game is over
      if (isGameOver || (settings.rounds !== 'unlimited' && currentRound >= totalRounds)) {
        nextRoundBtn.textContent = 'See Final Results';
        
        if (isGameOver && gameMode === 'solo' && lives !== Infinity) {
          // Reset any special styling
          roundResult.style.background = '';
          roundResult.style.padding = '';
          roundResult.style.borderRadius = '';
          
          roundResult.textContent = 'Game Over!';
          roundMessage.textContent = 'You ran out of lives!';
          roundResult.classList.remove('text-yellow-400');
          roundResult.classList.add('text-red-400');
        }
      } else {
        nextRoundBtn.textContent = 'Next Round';
      }
      
      // Handle button click
      nextRoundBtn.onclick = function() {
        roundCompletion.classList.add('hidden');
        
        // Now we stop the music as we transition
        musicPlayer.pause();
        stopMusicVisualizer();
        
        // Remove any "Continue" buttons that might still be present
        const timeoutBtn = document.getElementById('timeout-next-btn');
        if (timeoutBtn && timeoutBtn.parentNode) {
          timeoutBtn.parentNode.removeChild(timeoutBtn);
        }
        
        // Check if game should end or continue
        if (isGameOver || (settings.rounds !== 'unlimited' && currentRound >= totalRounds)) {
          endGame();
        } else {
          startNewRound();
        }
      };
      
      // Show round completion modal with faster fade-in effect
      roundCompletion.classList.remove('hidden');
      
      // Apply a faster animation
      roundCompletion.style.animation = 'quickFadeIn 0.3s forwards';
      
      // Set focus on next round button for keyboard users
      nextRoundBtn.focus();
      
      // Add quick fade-in animation if not already present
      if (!document.getElementById('quick-fade-in-style')) {
        const style = document.createElement('style');
        style.id = 'quick-fade-in-style';
        style.textContent = `
          @keyframes quickFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
          }
        `;
        document.head.appendChild(style);
      }
    }
    
    // End the game and show results
    function endGame() {
      // Make sure music is stopped for the final results screen
      musicPlayer.pause();
      stopMusicVisualizer();
      
      const finalScore = document.getElementById('final-score');
      const scoreMessage = document.getElementById('score-message');
      const resultsModal = document.getElementById('results-modal');
      const resultsContent = document.getElementById('results-content');
      const scoreTableBody = document.getElementById('score-table-body');
      const gameStats = document.getElementById('game-stats');
      
      // Show final score
      finalScore.textContent = `${score}/${totalRounds}`;
      
      // Generate score message
      const percentage = (score / totalRounds) * 100;
      if (percentage >= 90) {
        scoreMessage.textContent = 'Amazing! You are a true music genius!';
        scoreMessage.className = 'text-2xl font-bold text-center text-yellow-400 my-4 animate-pulseGrow';
        generateStars(25); // More stars for better performance
      } else if (percentage >= 70) {
        scoreMessage.textContent = 'Great! Your music knowledge is impressive!';
        scoreMessage.className = 'text-2xl font-bold text-center text-green-400 my-4 animate-pulseGrow';
        generateStars(15);
      } else if (percentage >= 50) {
        scoreMessage.textContent = 'Good! You could use a bit more practice.';
        scoreMessage.className = 'text-2xl font-bold text-center text-blue-400 my-4 animate-pulseGrow';
        generateStars(8);
      } else if (percentage >= 30) {
        scoreMessage.textContent = 'Not bad. You should listen to more music!';
        scoreMessage.className = 'text-2xl font-bold text-center text-purple-400 my-4 animate-pulseGrow';
        generateStars(4);
      } else {
        scoreMessage.textContent = 'Thanks for playing anyway!';
        scoreMessage.className = 'text-2xl font-bold text-center text-gray-400 my-4 animate-pulseGrow';
        generateStars(2);
      }
      
      // Update game statistics
      const averageResponseTime = responseTimeHistory.length > 0 
        ? responseTimeHistory.reduce((a, b) => a + b, 0) / responseTimeHistory.length / 1000 
        : 0;
      
      // Prepare the stats HTML
      let statsHTML = `
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 my-6">
          <div class="bg-gray-800 rounded-lg p-4 text-center animate-fadeInUp" style="animation-delay: 0.1s">
            <p class="text-gray-400 text-sm">Rounds Played</p>
            <p class="text-2xl font-bold">${currentRound}</p>
          </div>
          <div class="bg-gray-800 rounded-lg p-4 text-center animate-fadeInUp" style="animation-delay: 0.2s">
            <p class="text-gray-400 text-sm">Accuracy</p>
            <p class="text-2xl font-bold">${Math.round(percentage)}%</p>
          </div>`;
          
      // Add lives stat for Marathon mode
      if (gameMode === 'solo' && lives !== undefined) {
        statsHTML += `
          <div class="bg-gray-800 rounded-lg p-4 text-center animate-fadeInUp" style="animation-delay: 0.3s">
            <p class="text-gray-400 text-sm">Lives Left</p>
            <p class="text-2xl font-bold">${lives === Infinity ? '∞' : remainingLives}</p>
          </div>`;
      } else {
        statsHTML += `
          <div class="bg-gray-800 rounded-lg p-4 text-center animate-fadeInUp" style="animation-delay: 0.3s">
            <p class="text-gray-400 text-sm">Avg Response</p>
            <p class="text-2xl font-bold">${averageResponseTime.toFixed(1)}s</p>
          </div>`;
      }
      
      statsHTML += `
          <div class="bg-gray-800 rounded-lg p-4 text-center animate-fadeInUp" style="animation-delay: 0.4s">
            <p class="text-gray-400 text-sm">Game Mode</p>
            <p class="text-2xl font-bold">${gameMode.charAt(0).toUpperCase() + gameMode.slice(1)}</p>
          </div>
        </div>
      `;
      
      // Set the HTML
      gameStats.innerHTML = statsHTML;
      
      // Generate scoreboard for multiplayer
      scoreTableBody.innerHTML = '';
      
      if (['versus', 'team', 'coop'].includes(gameMode)) {
        // Sort players by score
        const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
        
        sortedPlayers.forEach((player, i) => {
          // Calculate accuracy percentage
          const accuracy = Math.round((player.score / totalRounds) * 100);
          
          const row = document.createElement('tr');
          row.className = i === 0 ? 'font-bold animate-fadeInUp' : 'animate-fadeInUp';
          row.style.animationDelay = `${0.1 + (i * 0.1)}s`;
          row.innerHTML = `
            <td class="py-3">
              <div class="flex items-center">
                ${i === 0 ? '<span class="text-yellow-400 mr-2">👑</span>' : (i === 1 ? '<span class="text-gray-300 mr-2">🥈</span>' : (i === 2 ? '<span class="text-amber-700 mr-2">🥉</span>' : ''))}
                <div class="h-7 w-7 rounded-full bg-gradient-to-br from-${player.color} to-indigo-600 p-0.5 mr-2">
                  <img src="src/img/avatars/${player.avatar}.png" alt="${player.name}'s Avatar" class="rounded-full">
                </div>
                ${player.name}
              </div>
            </td>
            <td class="py-3 text-center text-${player.color}-400">${player.score}</td>
            <td class="py-3 text-right">
              <span class="inline-block bg-gray-800 rounded-full px-2 py-1 text-sm">
                ${accuracy}%
              </span>
            </td>
          `;
          scoreTableBody.appendChild(row);
        });
      } else {
        // Solo mode - just show player's score
        const accuracy = Math.round((score / totalRounds) * 100);
        
        const row = document.createElement('tr');
        row.className = 'font-bold animate-fadeInUp';
        row.innerHTML = `
          <td class="py-3">
            <div class="flex items-center">
              <span class="text-yellow-400 mr-2">👑</span>
              You
            </div>
          </td>
          <td class="py-3 text-center text-purple-400">${score}</td>
          <td class="py-3 text-right">
            <span class="inline-block bg-gray-800 rounded-full px-2 py-1 text-sm">
              ${accuracy}%
            </span>
          </td>
        `;
        scoreTableBody.appendChild(row);
        
        // Add a tracks list of what was played
        const playedSummary = document.getElementById('played-tracks-summary');
        if (playedSummary) {
          playedSummary.innerHTML = '';
          
          // Get the last 5 tracks played
          const recentTracks = playedTracks.slice(-5);
          
          if (recentTracks.length > 0) {
            const tracksList = document.createElement('div');
            tracksList.className = 'mt-6';
            tracksList.innerHTML = `
              <h3 class="text-gray-300 text-sm uppercase tracking-wide mb-2">Recent Tracks</h3>
              <ul class="bg-gray-800 bg-opacity-50 rounded-lg overflow-hidden">
                ${recentTracks.map((track, i) => `
                  <li class="px-4 py-2 border-b border-gray-700 last:border-0 animate-fadeInUp" style="animation-delay: ${0.3 + (i * 0.1)}s">
                    <div class="flex items-center">
                      <span class="text-gray-400 text-sm mr-2">${i + 1}.</span>
                      <div>
                        <p class="font-medium">${track.artist_name} - ${track.cleanTitle || cleanSongTitle(track.title)}</p>
                        <p class="text-sm text-gray-400">${track.album ? track.album.title : 'Unknown Album'}</p>
                      </div>
                    </div>
                  </li>
                `).join('')}
              </ul>
            `;
            playedSummary.appendChild(tracksList);
          }
        }
      }
      
      // Create a small delay to show the modal with animation
      resultsModal.classList.remove('hidden');
      
      // Trigger confetti when showing results
      createConfetti();
      
      // Fade in animation
      setTimeout(() => {
        resultsModal.classList.add('show-modal');
        
        // Apply animation to the stars
        const stars = document.querySelectorAll('.star');
        stars.forEach(star => {
          star.style.animation = `rotateStar ${Math.random() * 5 + 5}s infinite linear`;
        });
      }, 100);
    }
    
    // Generate stars for the final screen
    function generateStars(count) {
      const starsContainer = document.querySelector('.stars-container');
      starsContainer.innerHTML = ''; // Clear any existing stars
      
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        
        // Randomize the star appearance
        const size = Math.random() * 20 + 10; // 10-30px
        const posX = Math.random() * 100; // Percentage position
        const posY = Math.random() * 100; // Percentage position
        const delay = Math.random() * 2; // 0-2s delay
        const duration = Math.random() * 3 + 2; // 2-5s animation duration
        
        // Apply the random styles
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.left = `${posX}%`;
        star.style.top = `${posY}%`;
        star.style.animationDelay = `${delay}s`;
        star.style.animationDuration = `${duration}s`;
        
        starsContainer.appendChild(star);
      }
    }
    
    // Create confetti effect - Improved and faster version
    function createConfetti() {
      // Quick flash effect
      const flash = document.createElement('div');
      flash.style.position = 'fixed';
      flash.style.top = '0';
      flash.style.left = '0';
      flash.style.width = '100vw';
      flash.style.height = '100vh';
      flash.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
      flash.style.zIndex = '999';
      flash.style.pointerEvents = 'none';
      document.body.appendChild(flash);
      
      // Faster flash animation
      flash.animate([
        { opacity: 0.3 },
        { opacity: 0 }
      ], {
        duration: 400, // Reduced from 800ms
        easing: 'ease-out'
      }).onfinish = () => flash.remove();
      
      const confettiCount = 150; // Optimized count for better performance
      const confettiContainer = document.createElement('div');
      confettiContainer.className = 'confetti-container';
      confettiContainer.style.position = 'fixed';
      confettiContainer.style.top = '0';
      confettiContainer.style.left = '0';
      confettiContainer.style.width = '100%';
      confettiContainer.style.height = '100%';
      confettiContainer.style.overflow = 'hidden';
      confettiContainer.style.zIndex = '1000';
      confettiContainer.style.pointerEvents = 'none';
      document.body.appendChild(confettiContainer);
      
      // Clean up confetti faster
      setTimeout(() => {
        if (confettiContainer.parentNode) {
          confettiContainer.remove();
        }
      }, 3000); // Reduced from 8000ms for faster cleanup
      
      // Bright and vibrant colors
      const colors = [
        '#FF1493', '#00BFFF', '#FFD700', '#32CD32', '#FF4500', '#9400D3', 
        '#FF69B4', '#1E90FF', '#FFFF00', '#00FF7F', '#FF6347', '#8A2BE2',
        '#FF00FF', '#00FFFF', '#FFA500', '#7FFF00', '#FF0000', '#0000FF'
      ];
      
      // Simpler shapes for better performance
      const shapes = ['circle', 'square', 'triangle', 'star'];
      
      // Create confetti pieces
      for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        
        // Mostly come from top for better visual effect
        confetti.style.left = `${Math.random() * 100}vw`;
        confetti.style.top = `${Math.random() * 30 - 20}vh`;
        
        // Random shape and color
        const shape = shapes[Math.floor(Math.random() * shapes.length)];
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        // Randomized size
        const size = Math.random() * 10 + 5;
        
        // Define shapes
        switch(shape) {
          case 'circle':
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;
            confetti.style.backgroundColor = color;
            confetti.style.borderRadius = '50%';
            break;
          case 'square':
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;
            confetti.style.backgroundColor = color;
            break;
          case 'triangle':
            confetti.style.width = '0';
            confetti.style.height = '0';
            confetti.style.backgroundColor = 'transparent';
            confetti.style.borderLeft = `${size}px solid transparent`;
            confetti.style.borderRight = `${size}px solid transparent`;
            confetti.style.borderBottom = `${size * 1.5}px solid ${color}`;
            break;
          case 'star':
            confetti.style.width = `${size * 1.5}px`;
            confetti.style.height = `${size * 1.5}px`;
            confetti.style.backgroundColor = color;
            confetti.style.clipPath = 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
            break;
        }
        
        // Faster animations
        const duration = Math.random() * 2 + 1; // 1-3 seconds (reduced from 3-8)
        const delay = Math.random() * 0.5; // Reduced delay for quicker start
        
        // Physics calculations
        const vx = Math.random() * 10 - 5;
        const vy = Math.random() * 10 + 15; // Falling effect
        const spin = Math.random() * 360 - 180;
        
        confetti.style.position = 'absolute';
        confetti.style.zIndex = '1001';
        confetti.style.pointerEvents = 'none';
        confetti.style.boxShadow = `0 0 ${Math.random() * 3 + 1}px ${color}`;
        confetti.style.opacity = Math.random() * 0.5 + 0.5;
        
        // Set CSS variables for animation
        confetti.style.setProperty('--vx', `${vx}`);
        confetti.style.setProperty('--vy', `${vy}`);
        confetti.style.setProperty('--spin', `${spin}`);
        
        // Apply animation
        confetti.style.animation = `confettiFall ${duration}s ${delay}s ease-in forwards`;
        
        confettiContainer.appendChild(confetti);
      }
      
      // Add animation style if not already present
      if (!document.getElementById('confetti-style')) {
        const style = document.createElement('style');
        style.id = 'confetti-style';
        style.textContent = `
          @keyframes confettiFall {
            0% {
              transform: translateY(0) translateX(0) rotate(0deg);
              opacity: 1;
            }
            25% {
              opacity: 1;
            }
            100% {
              transform: translateY(calc(var(--vy) * 50px)) 
                         translateX(calc(var(--vx) * 20px)) 
                         rotate(calc(var(--spin) * 1deg));
              opacity: 0;
            }
          }
        `;
        document.head.appendChild(style);
      }
      
      // No victory sounds as requested
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Answer buttons only - removed music control click handlers
      answerButtons.forEach(btn => {
        btn.addEventListener('click', handleAnswerClick);
      });
      
      // Müzik başlatmaya yardımcı olmak için tüm sayfa etkileşimlerini dinle
      const pageInteractionHandler = () => {
        // Sayfa etkileşimi algılandı, müziği başlatmayı dene
        if (musicPlayer.paused && musicPlayer.src) {
          musicPlayer.muted = false; // Ses açık
          musicPlayer.play().catch(e => {/* Autoplay attempt error handled silently */});
        }
        
        // Bu handler'ı tek kullanımlık yap
        document.removeEventListener('click', pageInteractionHandler);
        document.removeEventListener('touchstart', pageInteractionHandler);
        document.removeEventListener('keydown', pageInteractionHandler);
      };
      
      // Sayfa etkileşimi eventlerini dinle
      document.addEventListener('click', pageInteractionHandler);
      document.addEventListener('touchstart', pageInteractionHandler);
      document.addEventListener('keydown', pageInteractionHandler);
      
      // Results modal buttons
      document.getElementById('replay-btn').addEventListener('click', () => {
        window.location.reload();
      });
      
      document.getElementById('menu-btn').addEventListener('click', () => {
        window.location.href = '../index.html';
      });
    }
    
    // Utility: Shuffle array randomly
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
  </script>
  
  <!-- Script for main menu navigation -->
  <script>
    // Direct event listener for the main menu button
    document.addEventListener('DOMContentLoaded', function() {
      const mainMenuBtn = document.getElementById('mainMenuBtn');
      if (mainMenuBtn) {
        mainMenuBtn.addEventListener('click', function() {
          // Main menu button clicked handler
          window.location.href = '../index.html';
        });
        // Main menu button handler initialized
      } else {
        console.error('Main menu button not found');
      }
    });
  </script>
</body>
</html>
